#!/bin/bash
#################################################################
#   Rotary Random Password Generator                            #
#                     By Robert D. Wei (Freedman) 2015 July     #
#                                               License: GPL 2  #
#################################################################
readonly SysMax=2147483647
readonly OneMinuteCounts=100000000
readonly Lcase='abcdefghijklmnopqrstuvwxyz'
readonly Ucase='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
readonly Nums='0123456789'
readonly Symbs='!"#$%&'"'"'()*+,-./:;<=>?@[\]^_`{|}~'
readonly ThisTTY="$( tty )"
BOARD_color=""
BOARD_lnth=8
BOARD_candidStr=""
BOARD_ezmod=""
BOARD_auto=""
BOARD_chrCmp=""
BOARD_engine=""





case $LANG in
  zh_TW*)
    readonly _all_candidate_characters_are='候選字元：'
    readonly _rotor_size='轉輪大小：'
    readonly _slow_down_please='請減慢速度！'
    readonly _character='字元'
    readonly _rounds='轉'
    readonly _help_page="$( (while read ; do echo "$REPLY" ; done) <<- EOF
	*** 轉輪式隨機密碼產生器 ***

	請用 "./genpass [-a] [-c|-n] [密碼長度] [l][u][n][s] [-s ...]"
	    l:  小寫字母     u:  大寫字母
	    n:  數字　　     s:  其他符號    ( 預設值： luns )
	    -e:  簡易模式，使用 'lsunln' 作為候選符號的組合方式
	    -a:  自動產生密碼，以 /dev/random 作為隨機來源 ( 不建議使用！ )
	    -c/n:  彩色輸出 / 不使用彩色 ( 預設值： n )
	    -s:  將接下來的字串作為候選符號

	每按一次 '[Enter]' 產生一個隨機符號。

	註：準備好以後，執行本程式並取得密碼。＊不要＊為了不重要的理由，就重新
	　　再取一次密碼。過度篩選密碼會使得密碼變得可以預測。例如，如果每十個
	　　密碼裡，有九個因為太難記住而廢棄，那麼所有可能的密碼組合中，只有十
	　　分之一可能真正使用。瞭解這一點的攻擊者，在猜密碼的時候速度可以加快
	　　為十倍。
	　－－好記的密碼不好用，好用的密碼不好記－－
	EOF
	)"
    readonly _error_message="$( (while read ; do echo "$REPLY" ; done) <<- EOF
	請用 "$0 [-a] [-c|-n] [密碼長度] [l][u][n][s] [-s ...]"

	　或輸入 "$0 -h|--help" 取得說明
	EOF
	)"
    ;;


  *)
    readonly _all_candidate_characters_are='All candidate characters are:'
    readonly _rotor_size='Rotor size:'
    readonly _slow_down_please='Slow down, please!'
    readonly _character='Character'
    readonly _rounds='Rounds'
    readonly _help_page="$( (while read ; do echo "$REPLY" ; done) <<- EOF
	*** Rotary Random Password Generator ***

	Use "./genpass [-a] [-c|-n] [length of password] [l][u][n][s] [-s ...]"
	    l:  lowercase   u:  uppercase
	    n:  numbers     s:  other symbol    ( default:  luns )
	    -e:  easy mode, use 'lsunln' as the composition of the candidates
	    -a:  auto generate from /dev/random ( NOT RECOMMENDED! )
	    -c/n:  color / no color ( default: n )
	    -s:  use the following string as candidates

	Press '[Enter]' and generate one random character each time.

	Note:  Prepare yourself, then execute this program and get the password.
	       DO NOT re-generate a password for some unimportant reasons.
	       Over filtering will turn your random password predictable.  For
	       example, throwing away nine passwords from ten only because
	       they are too hard to remember, then only 10% of all possible
	       passwords will be use.  An attacker may speed up ten times
	       on guessing it by knowing that.
	 -- Easy passwords aren't strong, strong passwords aren't easy. --
	EOF
	)"
    readonly _error_message="$( (while read ; do echo "$REPLY" ; done) <<- EOF
	Use "$0 [-a] [-c|-n] [length of password] [l][u][n][s] [-s ...]"

	   or "$0 -h|--help" for help.
	EOF
	)"
    ;;
esac





function integer_large_enough() {
  declare -i BigInt=1

  while [ $BigInt -lt $(( BigInt *2 )) ] ; do
    BigInt=BigInt*2
  done

  test $(( $BigInt / $OneMinuteCounts )) -gt 1440
  return $?
}


function errOut() {
  echo
  echo "$_error_message"
  echo
  exit $1
}


function analysisArgs() {
  local arg cnt

  ### Special arguments ###
  if [ "$#" == "1" ] && [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
    echo
    echo "$_help_page"
    echo
    exit 0
  fi

  if [ "$1" == "engine" ] ; then
    BOARD_engine="1"
    BOARD_color="1"
    BOARD_lnth=12
    shift
  fi

  ### regular arguments ###
  while [ "$1" != "" ] ; do

    #### is length ####
    arg=$1
    while [ "$arg" != "${arg#[0-9]}" ] ; do arg="${arg#[0-9]}" ; done
    if [ "$arg" == "" ] ; then
      BOARD_lnth="$1"
      shift
      continue
    fi

    #### is composition of candidates ####
    arg=$1
    while [ "$arg" != "${arg#[luns]}" ] ; do arg="${arg#[luns]}" ; done
    if [ -z "$arg" ] ; then
      BOARD_chrCmp+=$1
      shift
      continue
    fi

    #### is candidate character string ####
    if [ "$1" == "-s" ] && [ -n "$2" ] ; then
      BOARD_candidStr+="$2"
      shift 2
      continue
    fi

    #### is other parameters ####
    if [ "${1:0:1}" = "-" ] && [ ${#1} -gt 1 ] ; then
      for ((cnt=1; cnt<${#1}; cnt++)) ; do
        case "${1:$cnt:1}" in
          "e")  BOARD_ezmod="1"  ;;
          "a")  BOARD_auto="1"   ;;
          "c")  BOARD_color="1"  ;;
          "n")  BOARD_color=""   ;;
          *)    errOut 1   ;;
        esac
      done
      shift
      continue
    fi

    errOut 1

  done
}


function candidateChars() {
  local rotor="$BOARD_candidStr"

  if [ -n "$BOARD_ezmod" ] ; then
    BOARD_chrCmp+="lsunln"
  fi

  if [ -z "$BOARD_chrCmp" ] && [ -z "$rotor" ] ; then
    BOARD_chrCmp="luns"
  fi

  for ((n=0; n<${#BOARD_chrCmp}; n++)) ; do
    case "${BOARD_chrCmp:$n:1}" in
      "l")  rotor+="$Lcase"  ;;
      "u")  rotor+="$Ucase"  ;;
      "n")  rotor+="$Nums"   ;;
      "s")  rotor+="$Symbs"  ;;
    esac
  done

  echo "$rotor"
}


function generatePasswd() {

  if [ -z "$BOARD_auto" ] ; then
    manualGenerate "$@"
  else
    autoGenerate "$@"
  fi
}

function manualGenerate() {
  local rotor="$1"
  declare -i rotrSiz=${#rotor} wndow=0
  declare -i wndoBndry=${SysMax}-${SysMax}%rotrSiz
  local minStep=$(( $rotrSiz * 100 ))
  local cnt rndPaswd

  if integer_large_enough ; then
    local IntegerLargeEnough=true
  else
    local IntegerLargeEnough=false
  fi

  if [ -n "$BOARD_engine" ]  ; then
    echo > $ThisTTY
    echo "$_all_candidate_characters_are" > $ThisTTY
    echo "$rotor" > $ThisTTY
    echo > $ThisTTY
    echo "$_rotor_size  $rotrSiz" > $ThisTTY
    echo > $ThisTTY
  fi

  for ((cnt=1; cnt<=$BOARD_lnth; cnt++)) ; do

    if $IntegerLargeEnough ; then
      until read -t 0 ; do
          wndow=wndow+1
      done
    else
      until read -t 0 ; do
          wndow=(wndow+1)%wndoBndry
      done
    fi
    read

    if [ -n "$BOARD_engine" ]  ; then
      echo -e "\E[1A$_character $cnt:  $(($wndow/$rotrSiz)) $_rounds" > $ThisTTY
    else
      echo -ne '\E[1A\E[K' > $ThisTTY
      [ $wndow -lt $minStep ] && echo -n "$_slow_down_please"
    fi
    wndow=wndow%rotrSiz
    rndPaswd+="${rotor:$wndow:1}"

  done

  echo -ne '\n\E[1A\E[K' > $ThisTTY
  echo "$rndPaswd"
}

function autoGenerate() {
  local rotor="$1"
  declare -i rotrSiz=${#rotor} wndow=0
  declare -i unitBndry=1 unitBits=0 rndBits=0 rndDat=0
  local minStep=$(( $rotrSiz * 100 ))
  local cnt rndPaswd

  while [ $unitBndry -lt $rotrSiz ] ; do
    unitBits=unitBits+1
    unitBndry=unitBndry*2
  done

  for ((cnt=1; cnt<=$BOARD_lnth; cnt++)) ; do
    wndow=rotrSiz
    until [ $wndow -lt $rotrSiz ] ; do
      while [ $rndBits -lt $unitBits ] ; do
        rndDat=rndDat+$(od -A n -i -N 1 /dev/random)*2**rndBits
        rndBits=rndBits+8
      done
      wndow=rndDat%unitBndry
      rndDat=rndDat/unitBndry
      rndBits=rndBits-unitBits
    done
    rndPaswd+="${rotor:$wndow:1}"
  done
  echo "$rndPaswd"
}


function outputPasswd() {
  local rndPaswd="$1"

  if [ -n "$BOARD_color" ] ; then
    rndPaswd="$( echo " $rndPaswd" \
                  | sed 's/\\/\\\\/g ;
                      s/\([a-z][a-z]*\)/ \1 /g ;
                      s/\([A-Z][A-Z]*\)/ \1 /g ; s/  / /g ; s/ $// ;
                      s/ \([a-z][a-z]*\)/\\E[34m\1/g ;
                      s/ \([A-Z][A-Z]*\)/\\E[31m\1/g ;
                      s/ /\\E[30m/g ; s/^/\\E[47m/ ; s/$/\\E[0m/' \
              )"
  fi

  echo -e "$rndPaswd"
}


function main() {
  local rotor rndPaswd

  analysisArgs "$@"

  rotor="$( candidateChars )"

  rndPaswd="$( generatePasswd "$rotor" )"

  outputPasswd "$rndPaswd"
}


main "$@"

