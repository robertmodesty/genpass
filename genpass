#!/bin/bash
#################################################################
#   Rotary Random Password Generator                            #
#                     By Robert D. Wei (Freedman) 2015 July     #
#                                               License: GPL 2  #
#################################################################
SysMax=2147483647
Lcase='abcdefghijklmnopqrstuvwxyz'
Ucase='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
Nums='0123456789'
Symbs='!"#$%&'"'"'()*+,-./:;<=>?@[\]^_`{|}~'
color=""
lnth=8

case $LANG in
  zh_TW*)
    slowDown='請減慢速度！'
    ;;
  *)  
    slowDown='Slow down, please!'
    ;;
esac

function helpPage() {
    case $LANG in
      zh_TW*) helpPageCT ;;
      *) helpPageEng ;;
    esac
}

function helpPageEng() {
    echo -e "\n*** Rotary Random Password Generator ***\n"
    echo 'Use "'$0' [-a] [-c|-n] [length of password] [l][u][n][s] [-s ...]"'
    echo "    l:  lowercase   u:  uppercase"
    echo "    n:  numbers     s:  other symbol    ( default:  luns )"
    echo "    -e:  easy mode, use 'lsunln' as the composition of the candidates"
    echo "    -a:  auto generate from /dev/random ( NOT RECOMMENDED! )"
    echo "    -c/n:  color / no color ( default: n )"
    echo "    -s:  use the following string as candidates"
    echo -e "\nPress '[Enter]' and generate one random character each time.\n"
    echo "Note:  Prepare yourself, then execute this program and get the password."
    echo "       DO NOT re-generate a password for some unimportant reasons."
    echo "       Over filtering will turn your random password predictable.  For"
    echo "       example, throwing away nine passwords from ten only because"
    echo "       they are too hard to remember, then only 10% of all possible"
    echo "       passwords will be use.  An attacker may speed up ten times"
    echo "       on guessing it by knowing that."
    echo -e " -- Easy passwords aren't strong, strong passwords aren't easy. --\n"
}

function helpPageCT() {
    echo -e "\n*** 轉輪式隨機密碼產生器 ***\n"
    echo '請用 "'$0' [-a] [-c|-n] [密碼長度] [l][u][n][s] [-s ...]"'
    echo "    l:  小寫字母     u:  大寫字母"
    echo "    n:  數字　　     s:  其他符號    ( 預設值： luns )"
    echo "    -e:  簡易模式，使用 'lsunln' 作為候選符號的組合方式"
    echo "    -a:  自動產生密碼，以 /dev/random 作為隨機來源 ( 不建議使用！ )"
    echo "    -c/n:  彩色輸出 / 不使用彩色 ( 預設值： n )"
    echo "    -s:  將接下來的字串作為候選符號"
    echo -e "\n每按一次 '[Enter]' 產生一個隨機符號。\n"
    echo "註：準備好以後，執行本程式並取得密碼。＊不要＊為了不重要的理由，就重新"
    echo "　　再取一次密碼。過度篩選密碼會使得密碼變得可以預測。例如，如果每十個"
    echo "　　密碼裡，有九個因為太難記住而廢棄，那麼所有可能的密碼組合中，只有十"
    echo "　　分之一可能真正使用。瞭解這一點的攻擊者，在猜密碼的時候速度可以加快"
    echo "　　為十倍。"
    echo -e "　－－好記的密碼不好用，好用的密碼不好記－－\n"
}

function errMsg() {
  case $LANG in
  zh_TW*)
    echo -e '\n請用 "'$0' [-a] [-c|-n] [密碼長度] [l][u][n][s] [-s ...]"'
    echo -e '\n　或輸入 "'$0' -h|--help" 取得說明\n'
    ;;
  *)
    echo -e '\nUse "'$0' [-a] [-c|-n] [length of password] [l][u][n][s] [-s ...]"'
    echo -e '\n   or "'$0' -h|--help" for help.\n'
    ;;
  esac
}

                ##########################
#################     Program start      #######################
                ##########################
if [ "$#" == "1" ] && [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
  helpPage
  exit 0
fi 

##########################
#    read parameters     #
##########################
if [ "$1" == "engine" ] ; then
  Eng="1"
  color="1"
  lnth=12
  shift
fi

chrCmp=""
rotor=""
while [ "$1" != "" ] ; do
  #### get length ####
  arg=$1
  while [ "$arg" != "${arg%[0-9]}" ] ; do arg="${arg%[0-9]}" ; done
  if [ "$arg" == "" ] ; then
    lnth=$1
    shift
    continue
  fi

  #### get composition of candidates ####
  arg=$1
  while [ "$arg" != "${arg%[luns]}" ] ; do arg="${arg%[luns]}" ; done
  if [ -z "$arg" ] ; then
    chrCmp+=$1
    shift
    continue
  fi

  #### get candidate character string ####
  if [ "$1" == "-s" ] ; then
    if [ -z "$2" ] ; then
      err="1"
    else
      rotor+="$2"
      shift
    fi
  #### other parameters ####
  elif [ "${1:0:1}" = "-" ] && [ ${#1} -gt 1 ] ; then
    for ((cnt=1; cnt<${#1}; cnt++)) ; do
      case "${1:$cnt:1}" in
        "e")
          ezmod="1"
          ;;
        "a")
          auto="1"
          ;;
        "c")
          color="1"
          ;;
        "n")
          color=""
          ;;
        *)
          err="1"
          ;; 
      esac
    done
  else
    err="1"
  fi

  #####################################
  #    show error message and exit    #
  #####################################
  if [ "$err" == "1" ] ; then
    errMsg
    exit 1
  fi

  shift
done

#########################################
#    composing the candidate string     #
#########################################
if [ -n "$ezmod" ] ; then chrCmp+="lsunln" ; fi
if [ -z "$chrCmp" ] && [ -z "$rotor" ] ; then chrCmp="luns" ; fi

for ((n=0; n<${#chrCmp}; n++)) ; do
  case "${chrCmp:$n:1}" in
  "l")
    rotor+="$Lcase"
    ;;
  "u")
    rotor+="$Ucase"
    ;;
  "n")
    rotor+="$Nums"
    ;;
  "s")
    rotor+="$Symbs"
    ;;
  esac
done

############################
#    generate password     #
############################
declare -i rotrSiz=${#rotor} wndow=0
minStep=$(( $rotrSiz * 100 ))
rndPaswd=""

if [ -z "$auto" ] ; then    ### by pressing [Enter] key.
  declare -i wndoBndry=$SysMax-$SysMax%$rotrSiz

  for ((cnt=0; cnt<$lnth; cnt++)) ; do
    until read -t 0 ; do
        wndow=(wndow+1)%wndoBndry
    done
    read
    if [ -n "$Eng" ]  ; then
      echo -e '\E[1A'"Pressing $(($cnt + 1)):  $(($wndow/$rotrSiz)) rounds"'\E[K'
    else
      echo -ne '\E[1A\E[K'
      [ $wndow -lt $minStep ] && echo -n "$slowDown" 
    fi
    wndow=wndow%rotrSiz
    rndPaswd+="${rotor:$wndow:1}"
  done
  echo -ne '\n\E[1A\E[K'

else      ############### Auto mode, from /dev/random
  declare -i unitBndry=1 unitBits=0 rndBits=0 rndDat=0
  while [ $unitBndry -lt $rotrSiz ] ; do
    unitBits=unitBits+1
    unitBndry=unitBndry*2
  done

  for ((cnt=0; cnt<$lnth; cnt++)) ; do
    wndow=rotrSiz
    until [ $wndow -lt $rotrSiz ] ; do
      while [ $rndBits -lt $unitBits ] ; do
        rndDat=rndDat+$(od -A n -i -N 1 /dev/random)*2**rndBits
        rndBits=rndBits+8
      done
      wndow=rndDat%unitBndry
      rndDat=rndDat/unitBndry
      rndBits=rndBits-unitBits
    done
    rndPaswd+="${rotor:$wndow:1}"
  done
fi


#############################
#    Output the password    #
#############################
if [ -n "$color" ] ; then
  rndPaswd="$(echo " $rndPaswd" | sed 's/\\/\\\\/g ;
                   s/\([a-z][a-z]*\)/ \1 /g ;
                   s/\([A-Z][A-Z]*\)/ \1 /g ; s/  / /g ; s/ $// ;
                   s/ \([a-z][a-z]*\)/\\E[34m\1/g ;
                   s/ \([A-Z][A-Z]*\)/\\E[31m\1/g ;
                   s/ /\\E[30m/g ; s/^/\\E[47m/ ; s/$/\\E[0m/')"
fi

echo -e "$rndPaswd"
